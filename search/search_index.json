{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"index.html","title":"Welcome to TWILIGHT Wiki","text":""},{"location":"index.html#twilight-video-tutorial","title":"TWILIGHT Video Tutorial","text":""},{"location":"index.html#introduction","title":"Introduction","text":""},{"location":"index.html#overview","title":"Overview","text":"<p>TWILIGHT (Tall and Wide Alignments at High Throughput) is an innovative MSA tool designed to leverage massive parallelism for efficient handling of tall and wide alignment tasks. It is able to scale to millions of long nucleotide sequences (&gt;10000 bases). TWILIGHT can run on CPU-only platforms (Linux/Mac) or take advantage of CUDA-capable GPUs for further acceleration.</p> <p>By default, TWILIGHT requires an unaligned sequence file in FASTA format and an input guide tree in Newick format to generate the output alignment in FASTA format (Fig. 1a, see TWILIGHT Default Mode for more details). When a guide tree is unavailable, users can utilize the iterative mode, which provides a Snakemake workflow to estimate guide trees using external tools (Fig. 1b, see TWILIGHT Iterative Mode for more details).</p> <p>TWILIGHT adopts the progressive alignment algorithm (Fig. 1c) and employs tiling strategies to band alignments (Fig. 1e). Combined with a divide-and-conquer technique (Fig. 1a), a novel heuristic dealing with gappy columns (Fig. 1d) and support for GPU acceleration (Fig. 1f), TWILIGHT demonstrates exceptional speed and memory efficiency.  </p> Figure 1: Overview of TWILIGHT algorithm"},{"location":"index.html#key-features","title":"Key Features","text":""},{"location":"index.html#divide-and-conquer-technique","title":"Divide-and-Conquer Technique","text":"<p>TWILIGHT's divide-and-conquer technique (Fig. 1a) starts by dividing the initial guide tree into smaller subtrees with at most m leaves, which controls memory usage by limiting the number of sequences processed at once. TWILIGHT sequentially iterates over each subtree, loading its corresponding sequences into memory, and computing the subalignment for the subtree. After all subalignments are computed, TWILIGHT merges subalignments with transitivity merger algorithm of PASTA (Mirarab et al., 2015) or progressive alignment.  </p>"},{"location":"index.html#progressive-alignment-and-scheduling","title":"Progressive Alignment and Scheduling","text":"<p>TWILIGHT performs progressive alignment based on the guide tree structure, first aligning the most similar sequences or sequence groups and then progressively adding less similar sequences or groups. The scheduling algorithm (Fig. 1c) initializes the leaf nodes and then performs a post-order traversal to set the alignment order for internal nodes. This approach allows certain child nodes (e.g., a, b, d, f) to be aligned in parallel, while others (e.g., c, e, g) are processed sequentially, ensuring efficient parallel processing while respecting tree dependencies.  </p>"},{"location":"index.html#removing-gappy-columns","title":"Removing gappy columns","text":"<p>As more sequences are added, the alignment tends to grow longer, often with many gap-dominated columns, leading to increased computational time. To improve efficiency, TWILIGHT excludes gappy columns (Fig. 1d)\u2014where gaps exceed a specified threshold\u2014before the alignment step, resulting in shorter profiles and reducing computational overhead. After the alignment step, TWILIGHT restores the excluded gappy columns. If gappy columns from both profiles align at the same position, they are merged, reducing the overall alignment length. Otherwise, a gappy column from one profile is aligned with a new gap introduced in the other profile.  </p>"},{"location":"index.html#banded-alignment-and-tiling-strategy","title":"Banded Alignment and Tiling Strategy","text":"<p>TWILIGHT employs a modified X-Drop algorithm to control memory usage in pairwise profile alignment, ensuring linear scaling with sequence length. However, storing traceback pointers in limited GPU shared memory still poses challenges. To address this, TWILIGHT integrates the TALCO tiling algorithm  (Walia et al., 2024) (Fig. 1e), which limits traceback storage to a constant memory usage by using convergence pointers.  </p>"},{"location":"index.html#parallelization-techniques","title":"Parallelization Techniques","text":"<p>TWILIGHT employs parallelization techniques on both CPU and GPU to maximize efficiency. On CPUs, it is implemented in C++ with Threading Building Blocks (TBB) to exploit thread-level parallelism, processing independent alignments in parallel while also parallelizing profile calculations and sequence updates. On GPUs, TWILIGHT utilizes three levels of parallelism (Fig. 1f): multi-GPU parallelism distributes alignment tasks into batches and sends to multiple GPUs, inter-alignment parallelism assigns each GPU thread block to a pairwise profile alignment, and intra-alignment parallelism processes multiple cells in the dynamic programming matrix wavefront simultaneously.  </p> <p></p>"},{"location":"index.html#installation-methods","title":"Installation Methods","text":""},{"location":"index.html#installation-summary-choose-your-installation-method","title":"Installation summary (choose your installation method)","text":"<p>TWILIGHT offers multiple installation methods for different platforms and hardware setups:</p> <ul> <li>Conda is recommended for most users needing the default mode and partial iterative mode support, as some tree tools may be unavailable on certain platforms.</li> <li>Install script is required for AMD GPU support.</li> <li>Docker (built from the provided Dockerfile) is recommended for full support for iterative mode.</li> </ul> Platform / Setup Conda Script Docker Linux (x86_64) \u2705 \u2705 \u2705 Linux (aarch64) \u2705 \u2705 \ud83d\udfe1 macOS (Intel Chip) \u2705 \u2705 \u2705 macOS (Apple Silicon) \u2705 \u2705 \ud83d\udfe1 NVIDIA GPU \u2705 \u2705 \u2705 AMD GPU \u274c \u2705 \u274c <p>Note</p> <p>\ud83d\udfe1 The Docker image is currently built for the <code>linux/amd64</code> platform. While it can run on <code>arm64</code> systems (e.g., Apple Silicon or Linux aarch64) via emulation, this may lead to reduced performance.</p> <p>Note</p> <p>\u26a0\ufe0f To enable GPU support, the appropriate GPU drivers must be installed on the host system. This applies to all installation methods (Installation script, Conda, and Docker). The CUDA toolkits and libraries are included in Conda and Docker setups, but must be installed manually when using the installation script.  </p>"},{"location":"index.html#using-conda","title":"Using Conda","text":"<p>TWILIGHT is available on multiple platforms via Conda. See TWILIGHT Bioconda Page for details.  </p> <ol> <li> Install Conda (if not installed)     <pre><code># Replace &lt;PLATFORM&gt; with the actual platform of your system\n# See https://repo.anaconda.com/miniconda/ for details\nwget https://repo.anaconda.com/miniconda/Miniconda3-latest-&lt;PLATFORM&gt;.sh\nchmod +x Miniconda3-latest-&lt;PLATFORM&gt;.sh\n./Miniconda3-latest-&lt;PLATFORM&gt;.sh\nexport PATH=\"$HOME/miniconda3/bin:$PATH\"\n# Reload shell configuration\nsource ~/.bashrc  # For Bash (Most Linux)\nsource ~/.zshrc   # For Zsh (Default in Mac)\n</code></pre></li> <li>Create and activate a Conda environment     <pre><code>conda create -n twilight python=3.11 -y\nconda activate twilight\n# Set up channels\nconda config --add channels defaults\nconda config --add channels bioconda\nconda config --add channels conda-forge\nconda config --set channel_priority strict\n# Install TWILIGHT\nconda install bioconda::twilight\n</code></pre></li> <li>Install TWILIGHT iterative mode     <pre><code>git clone https://github.com/TurakhiaLab/TWILIGHT.git\ncd TWILIGHT\nbash ./install/installIterative.sh\n</code></pre></li> </ol>"},{"location":"index.html#using-installation-script-requires-sudo-access","title":"Using installation script (requires sudo access)","text":"<p>Users without sudo access are advised to install TWILIGHT via Conda or Docker.</p> <ol> <li>Clone the repository     <pre><code>git clone https://github.com/TurakhiaLab/TWILIGHT.git\ncd TWILIGHT\n</code></pre></li> <li>Install dependencies (requires sudo access)     TWILIGHT depends on the following common system libraries, which are typically pre-installed on most development    environments:     <pre><code>- wget\n- build-essential \n- cmake \n- libboost-all-dev \n</code></pre>     It also requires <code>libtbb-dev</code>, which is not always pre-installed on all systems. For users who do not have sudo     access and are missing only <code>libtbb-dev</code>, our script builds and installs TBB from source in the local user  environment, with no sudo access required.     For Ubuntu users with sudo access, if any of the required libraries are missing, you can install them with:     <pre><code>sudo apt install -y wget build-essential libboost-all-dev cmake libtbb-dev\n</code></pre>     For Mac users, install dependencies using Homebrew:     <pre><code>xcode-select --install # if not already installed\nbrew install wget boost cmake tbb\n</code></pre></li> <li>Build TWILIGHT     Our build script automatically detects the best available compute backend (CPU, NVIDIA GPU, or AMD GPU) and builds TWILIGHT accordingly. Alternatively, users can manually specify the desired target platform.     Automatic build:     <pre><code>bash ./install/buildTWILIGHT.sh\n</code></pre>     Build for a specific platform:     <pre><code>bash ./install/buildTWILIGHT.sh cuda # For NVIDIA GPUs\nbash ./install/buildTWILIGHT.sh hip  # For AMD GPUs\n</code></pre></li> <li>The TWILIGHT executable is located in the <code>bin</code> directory and can be run as follows:     <pre><code>cd bin\n./twilight --help\n</code></pre></li> <li>(optional) Install TWILIGHT iterative mode (ensure Conda is installed first)     <pre><code># Create and activate a Conda environment \nconda create -n twilight python=3.11 -y\nconda activate twilight\n# Install Snakemake and tree inference tools\nbash ./install/installIterative.sh\n</code></pre></li> </ol>"},{"location":"index.html#using-dockerfile","title":"Using Dockerfile","text":"<p>The Dockerfile installed all the dependencies and tools for TWILIGHT default/iterative mode.  </p> <ol> <li>Clone the repository <pre><code>git clone https://github.com/TurakhiaLab/TWILIGHT.git\ncd TWILIGHT\n</code></pre></li> <li>Build the docker image     CPU version <pre><code>cd docker/cpu\ndocker build -t twilight .\n</code></pre>     GPU version (using nvidia/cuda as base image) <pre><code>cd docker/gpu\ndocker build -t twilight .\n</code></pre></li> <li>Start and run docker container      CPU version     <pre><code>docker run --platform=linux/amd64 -it twilight\n</code></pre>     GPU version <pre><code>docker run --platform=linux/amd64 --gpus all -it twilight\n</code></pre></li> <li>Run TWILIGHT     <pre><code>./twilight --help\n</code></pre></li> </ol>"},{"location":"index.html#run-twilight","title":"Run TWILIGHT","text":""},{"location":"index.html#twilight-command-line-interface-cli","title":"TWILIGHT Command Line Interface (CLI)","text":""},{"location":"index.html#main-functionalities","title":"Main Functionalities","text":"<ol> <li>Build MSA from unaligned Sequences (Default Mode)</li> <li>Merging Multiple MSAs</li> <li>Add New Sequences to an Existing Alignment</li> </ol>"},{"location":"index.html#command-line-options","title":"Command Line Options","text":"Table 1: List of command line options supported by TWILIGHT  Option Description Inputs Build MSA from unaligned Sequences (Default Mode) <code>-t</code>, <code>--tree</code> Input guide tree file in Newick format (required). <code>-i</code>, <code>--sequences</code> Input unaligned sequences file in FASTA format (required). Merging Multiple MSAs <code>-f</code>, <code>--files</code> Path to the directory containing all MSA files in FASTA format to be merged. Add New Sequences to an Existing Alignment <code>-t</code>, <code>--tree</code> Input tree file in Newick format with placements for sequences to be aligned (optional). <code>-i</code>, <code>--sequences</code> Input unaligned sequences file in FASTA format (required). <code>-a</code>, <code>--alignment</code> Backbone MSAs in FASTA format (required). Outputs/Files <code>-o</code>, <code>--output</code> Output MSA file name (required). <code>-d</code>, <code>--temp-dir</code> Directory for storing temporary files. Used when <code>-f</code> or <code>-m</code> is specified. <code>-k</code>, <code>--keep-temp</code> Keep the temporary directory (default: disabled). <code>--overwrite</code> Force overwriting the temporary and output files (default: disabled). <code>--write-prune</code> Write the pruned tree to the output directory (must be used with <code>--prune</code>, default: disabled). Hardware Usage <code>-C</code>, <code>--cpu</code> Number of CPU cores (default: all available cores). Options only for GPU version <code>-G</code>, <code>--gpu</code> Number of GPU (default: all available GPUs). <code>--gpu-index</code> Specify the GPU to be used, separated by commas. For example, <code>0,2,3</code> uses 3 GPUs with the index 0, 2 and 3. <code>--cpu-only</code> Run the program only using CPU. Alignment Parameters <code>--type</code> Data type: <code>n</code> for nucleotide, <code>p</code> for protein. Automatically inferred if not specified. <code>-m</code>, <code>--max-subtree</code> Maximum number of leaves per subtree; enables divide-and-conquer method (default: <code>INT_MAX</code>). <code>-r</code>, <code>--remove-gappy</code> Threshold for removing gappy columns (set to 1 to disable, default: 0.95). <code>--prune</code> Prune the input guide tree based on the presence of unaligned sequences (default: disabled). <code>-w</code>, <code>--wildcard</code> Treat unknown or ambiguous bases as wildcards and align them to usual letters (default: disabled). <code>--no-align-gappy</code> Do not align gappy columns; this will create a longer MSA (default: disabled). <code>--length-deviation</code> Sequences whose lengths deviate from the average by more than the specified fraction will be deferred or excluded (default: disabled). <code>--max-ambig</code> Sequences with an ambiguous character proportion exceeding the specified threshold will be deferred or excluded (default: 0.1). <code>--filter</code> Exclude sequences with high ambiguity or length deviation (default: disabled.) <code>--merge</code> Method to merge subtrees: <code>t</code> for Transitivity Merger and <code>p</code> for Progressive Alignment (default: <code>p</code>). Scoring Parameters <code>--match</code> Match score (default: 18). <code>--mismatch</code> Mismatch penalty for transversions (default: -8). <code>--transition</code> Score for transition (default: -4). <code>--gap-open</code> Gap-open penalty (default: -50). <code>--gap-extend</code> Gap-extend penalty (default: -5). <code>-x</code>, <code>--matrix</code> User-specified substitution matrix path. <code>--xdrop</code> X-drop value (scale). The actual X-drop will be multiplied by the gap-extend penalty (default: 600). General <code>--check</code> Check the final alignment. Sequences with no legal alignment will be displayed. <code>-v</code>, <code>--verbose</code> Print out every detail process. <code>-h</code>, <code>--help</code> Print help messages and exit. <code>--version</code> Show TWILIGHT version and exit."},{"location":"index.html#usages-and-examples","title":"Usages and Examples","text":"<p>Note</p> <p>All files used for the examples below can be found in <code>TWILIGHT/dataset</code>.</p> <p>Enter into the build directory (assuming <code>$TWILIGHT_HOME</code> directs to the TWILIGHT repository directory) <pre><code>cd $TWILIGHT_HOME/bin\n./twilight -h # See Help Messages\n</code></pre></p>"},{"location":"index.html#build-msa-from-unaligned-sequences-default-mode","title":"Build MSA from unaligned Sequences (Default Mode)","text":"<p>Generate MSA by giving an unaligned sequence file and a guide tree file.  </p> <ul> <li>Usage syntax <pre><code>./twilight -t &lt;tree file&gt; -i &lt;sequence file&gt; -o &lt;output file&gt;\n</code></pre></li> <li>Example <pre><code>./twilight -t ../dataset/RNASim.nwk -i ../dataset/RNASim.fa -o RNASim.aln\n</code></pre></li> </ul>"},{"location":"index.html#merge-multiple-msas","title":"Merge Multiple MSAs","text":"<p>Assume a star-tree structure to merge multiple MSAs. Please move all MSA files to be merged into one folder.  </p> <ul> <li>Usage syntax <pre><code>./twilight -f &lt;path to the folder&gt; -o &lt;output file&gt;\n</code></pre></li> <li>Example <pre><code>./twilight -f ../dataset/RNASim_subalignments/ -o RNASim.aln\n</code></pre></li> </ul>"},{"location":"index.html#add-new-sequences-to-an-existing-alignment","title":"Add New Sequences to an Existing Alignment","text":"<p>For better accuracy, it is recommended to use a tree that includes placements for the new sequences. If no tree is provided, TWILIGHT aligns new sequences to the profile of the entire backbone alignment, which may reduce accuracy. In this case, using the provided Snakemake workflow is advised.</p> <ul> <li>Usage syntax <pre><code>./twilight -a &lt;backbone alignment file&gt; -i &lt;new sequence file&gt; -t &lt;tree with placement of new sequences&gt; -o &lt;path to output file&gt;\n</code></pre></li> <li>Example <pre><code>./twilight -a ../dataset/RNASim_backbone.aln -i ../dataset/RNASim_sub.fa -t ../dataset/RNASim.nwk -o RNASim.aln\n</code></pre></li> </ul>"},{"location":"index.html#divide-and-conquer-method","title":"Divide-and-Conquer Method","text":"<p>Divide tree into subtrees with at most m leaves and align them sequentially to reduce the CPU\u2019s main memory usage.</p> <ul> <li>Usage syntax <pre><code>./twilight -t &lt;path to tree file&gt; -i &lt;path to sequence file&gt; -o &lt;path to output file&gt; -m &lt;maximum subtree size&gt;\n</code></pre></li> <li>Example <pre><code>./twilight -t ../dataset/RNASim.nwk -i ../dataset/RNASim.fa -o RNASim.aln -m 200\n</code></pre></li> </ul>"},{"location":"index.html#flexible-tree-support","title":"Flexible Tree Support","text":"<p>Prunes tips that are not present in the unaligned sequence file. This is useful when working with a large tree but only aligning a subset of sequences, without needing to re-estimate the guide tree. Outputting the pruned tree is also supported.</p> <ul> <li>Usage syntax <pre><code>./twilight -t &lt;large tree file&gt; -i &lt;subset of raw sequences&gt; -o &lt;output file&gt; --prune [--write-prune]\n</code></pre></li> <li>Example <pre><code>./twilight -t ../dataset/RNASim.nwk -i ../dataset/RNASim_sub.fa -o RNASim_sub.aln --prune --write-prune\n</code></pre></li> </ul>"},{"location":"index.html#snakemake-workflow","title":"Snakemake Workflow","text":"<p>TWILIGHT uses the Snakemake workflow to integrate external tools for estimating guide trees and placing new sequences. These are used in iterative mode or when aligning new sequences to existing alignments. For setting up the environment and installing external tools, see here.  </p>"},{"location":"index.html#main-functionalities_1","title":"Main Functionalities","text":"<ol> <li>Iterative Mode</li> <li>Add New Sequences to an Existing Alignment (Placement Mode)</li> </ol>"},{"location":"index.html#command-line-configurations","title":"Command Line Configurations","text":"Configurations Description and Options Snakemake Workflow Configurations <code>-n</code> Dry run, check workflow. <code>--cores</code> Number of CPU cores to use (default: all available cores). Some Snakemake versions may require this to be explicitly set. User-defined Configurations (used with <code>--config</code>) Iterative Mode <code>SEQ</code> Input unaligned sequences file in FASTA format (required). <code>INITTREE</code> Tree method for initial guide tree, options: <code>parttree</code>, <code>maffttree</code> or <code>mashtree</code>. (default: <code>parttree</code>). <code>ITERTREE</code> Tree method for for intermediate steps, options: <code>rapidnj</code> or <code>fasttree</code>. (default: <code>rapidnj</code>). Add New Sequences to an Existing Alignment (Placement Mode) <code>SEQ</code> New sequences in FASTA format to be placed and aligned (required). <code>ALN</code> Backbone alignment in FASTA format for placing new sequences (required.) <code>TREE</code> Backbone tree (optional; FastTree will be used for estimation if not provided). General <code>TYPE</code> Input sequence type, options: <code>n</code> for nucleotide or <code>p</code> for protein sequences (required). <code>OUT</code> Output MSA file path (required). <code>DIR</code> Directory for storing temporary files. <code>ITER</code> Number of iterations (default: 3 for Iterative Mode and 2 for Placement Mode). <code>FINALTREE</code> Final tree estimation method (skip if unspecified), options: <code>fasttree</code>, <code>raxml</code> or <code>iqtree</code>. <code>KEEP</code> Keep the temporary files, options: <code>yes</code> or <code>no</code> (default: <code>no</code>). <code>OVERWRITE</code> Overwrite the existing files, options: <code>yes</code> or <code>no</code> (default: <code>no</code>). <p>Note</p> <p>Default options in <code>workflow/config.yaml</code> will be used if the configuration is not specified. You can also modify <code>workflow/config.yaml</code> to set your options.</p> <p>Note</p> <p>For users who install TWILIGHT via Conda, please replace the executable path <code>\"../bin/twilight\"</code> with <code>\"twilight\"</code> in <code>config.yaml</code>. Feel free to switch to a more powerful tree tool if available, such as replacing <code>\"raxmlHPC\"</code> with <code>\"raxmlHPC-PTHREADS-AVX2\"</code> for better performance. </p>"},{"location":"index.html#usages-and-examples_1","title":"Usages and Examples","text":"<p>Enter <code>workflow</code> directory and type <code>snakemake</code> to view the help messages.  <pre><code>cd workflow\nsnakemake\n# or, for Snakemake versions that require specifying total number of cores:\nsnakemake --cores 1\n</code></pre></p>"},{"location":"index.html#iterative-mode","title":"Iterative Mode","text":"<p>TWILIGHT iterative mode estimate guide trees using external tools. </p> <ul> <li>Usage syntax <pre><code>snakemake [--cores &lt;num threads&gt;] --config TYPE=VALUE SEQ=VALUE OUT=VALUE [OPTION=VALUE ...]\n</code></pre></li> <li>Example - Using default configurations <pre><code>snakemake --cores 8 --config TYPE=n SEQ=../dataset/RNASim.fa OUT=RNASim.aln\n</code></pre></li> <li>Example - Generates the final tree based on the completed MSA. <pre><code>snakemake --cores 8 --config TYPE=n SEQ=../dataset/RNASim.fa OUT=RNASim.aln FINALTREE=fasttree\n</code></pre></li> </ul>"},{"location":"index.html#add-new-sequences-to-an-existing-alignment-placement-mode","title":"Add New Sequences to an Existing Alignment (Placement Mode)","text":"<p>TWILIGHT aligns new sequences to the profile of the backbone alignment, infers their placement with external tools, and then refines the alignment using the inferred tree.  </p> <ul> <li>Usage syntax <pre><code>snakemake [--cores &lt;num threads&gt;] --config TYPE=VALUE SEQ=VALUE OUT=VALUE ALN=VALUE [OPTION=VALUE ...]\n</code></pre></li> <li>Example - The backbone alignment is accompanied by a tree. <pre><code>snakemake --cores 8 --config TYPE=n SEQ=../dataset/RNASim_sub.fa OUT=RNASim.aln ALN=../dataset/RNASim_backbone.aln TREE=../dataset/RNASim_backbone.nwk\n</code></pre></li> <li>Example - The backbone tree is unavailable, estimate it using external tools and generate a final tree after alignment. <pre><code>snakemake --cores 8 --config TYPE=n SEQ=../dataset/RNASim_sub.fa OUT=RNASim.aln ALN=../dataset/RNASim_backbone.aln FINALTREE=fasttree\n</code></pre></li> </ul>"},{"location":"index.html#contributions","title":"Contributions","text":"<p>We welcome contributions from the community to enhance the capabilities of TWILIGHT. If you encounter any issues or have suggestions for improvement, please open an issue on TWILIGHT GitHub page. For general inquiries and support, reach out to our team.</p>"},{"location":"index.html#citing-twilight","title":"Citing TWILIGHT","text":"<p>If you use the TWILIGHT in your research or publications, we kindly request that you cite the following paper:  </p> <p>Yu-Hsiang Tseng, Sumit Walia, Yatish Turakhia, \"Ultrafast and ultralarge multiple sequence alignments using TWILIGHT\", Bioinformatics, Volume 41, Issue Supplement_1, July 2025, Pages i332\u2013i341, doi: 10.1093/bioinformatics/btaf212</p>"}]}